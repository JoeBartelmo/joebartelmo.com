I"Ã<p>Weâ€™re going to be doing a brief discussion on an approach to attacking client-side video games. I am going to make several assumptions about our reader: youâ€™re experienced with binary (and hexadecimal), you understand basic computer science skills (can program and understand hash-tables and computational organization), and you hate losing games.</p>

<h3 id="understanding-file-parsing">Understanding File Parsing</h3>

<p>When video games first came out, this topic would be trivial. We would simply do a quick look to figure out where are save files are stored on our operating system, and then we would just modify the values in that file. Often times, <a href="https://www.w3schools.com/xml/xml_whatis.asp">XML</a> or <a href="https://en.wikipedia.org/wiki/INI_file">INI</a> would be used to store the information. This wasnâ€™t a big deal for developers because we often did not have to share the information with servers or vast networks like we do now, so there is no reason to secure the information. As the first online games were introduced, so too was the ability to manipulate the online content, and then security was put in place to prevent this: checksums, custom serialization, endianness, custom primitive storage, etc. This article will be talking primarily about client-side attacks to a video game, pertaining chiefly to custom, developer made save-files.</p>

<h3 id="top-down-approach">Top Down Approach</h3>

<p>Letâ€™s take a look at an example before we continue. A popular client side game weâ€™ve all loved at one time or another is Skyrim. Generally the tools I use are restricted to a hex editor and some arbitrary language IDE open on the side to implement as I go. For Linux the hex editor I recommend is <a href="https://github.com/bwrsandman/Bless">Bless</a> and for Windows definitely use <a href="https://mh-nexus.de/en/hxd/">HxD</a>. For this example Iâ€™m going to stick to python, itâ€™s easy to translate into other languages.</p>

<p><img src="/assets/images/file1.png" alt="Skyrim Save 1" class="img-responsive" />
<img src="/assets/images/file2.png" alt="Skyrim Save 2" class="img-responsive" />
<img src="/assets/images/file3.png" alt="Skyrim Save 3" class="img-responsive" /></p>

<p>A Top Down approach is literally just that, we are going to start at the very top of this file and work our way down until we have successfully built our own implementation of an interpretor for this file format.</p>

<p>Now, Skyrim has an enormous amount of data they store in their save files, so weâ€™re going to primarily be focusing on the header information. The same skills can be extrapolated and applied to the rest of the save file. You have probably realized at this point that this seems a daunting task, especially with the currently exposed information. The problem that you have as the audience is a lack of info. We need more information if weâ€™re even going to come close to dissecting this, a classic scientific method, we need controls. So letâ€™s get a few more save files, and have all the saves readily available off to the side in Skyrim to load at well with any hypothesis we wish to test.</p>

<h4 id="tldr-generalized-explicit-recap-thus-far">TLDR Generalized Explicit Recap Thus far</h4>

<ul>
  <li>Take your current Save file and make a copy of it, put it in a save directory</li>
  <li>Do something in game, save again, make a copy of it, put it in a save directory</li>
  <li>Repeat n times (recommend ~5 to have a solid group of saves)</li>
  <li>Have the game open off to the side with all save games loadable.</li>
</ul>

<h4 id="to-the-code">To the Code</h4>

<p>So now letâ€™s get into the nitty-gritty details of our operation. We will be performing our topdown approach to the header of the Skyrim file. Observe the following files below:</p>

<p>We can immediately see a few commonalities between them, and that is our wonderful human brain at work that has been trained to identify patterns all of our life. Letâ€™s start with the file MAGIC (file signature). This is a commonality that all developers ubiquitously present when they make a customized file format. It serves as a marker for the reader to identify the file with easy to verify that it is, indeed, able to be read. Our signature looks like <code class="language-plaintext highlighter-rouge">54 45 53 56 5F 53 41 56 45 47 41 4D 45</code> or in ASCII <code class="language-plaintext highlighter-rouge">TESV_SAVEGAME</code>. Letâ€™s move over to our python script now that weâ€™ve identified the first feature.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""
TESV Save game file editor example (Top Down Approach)
:author Joe Bartelmo
:filename tesv.py
:version 3.6
"""</span>

<span class="k">class</span> <span class="nc">TESVSaveGame</span><span class="p">():</span>
    <span class="s">"""
    Wrapper to read and write our TESV Save game
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">open_immediately</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="s">"""
        Constructor for our file editor
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">open_immediately</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">open_stream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">close_stream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Closes the initialized stream
        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">opened</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Closing Stream'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">open_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Opens the initialized stream
        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">opened</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Opening Stream'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">filepath</span><span class="p">,</span> <span class="s">'rb+'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">assert_magic</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">assert_magic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Assert that the file signature is present
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="s">"TESV_SAVEGAME"</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">13</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">actual</span><span class="p">,</span> <span class="n">expected</span> <span class="o">+</span> <span class="s">" != "</span> <span class="o">+</span> <span class="n">actual</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'-d'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'usage: python testv.py &lt;tesv_savegane&gt; [-d]'</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">&lt;tesv_savegame&gt; location of skyrim savefile'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">()</span>
    <span class="n">TESVSaveGame</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>
<p>So some advanced notes for development here: Never read in the whole file at once: parse the data, then write back. If anything we will read blocks of like-aligned data (eg: a zip file inside our file, or a checksum block). We do not read the whole file because it can be costly to our memory and there is no benefit from it because we are modifying this file anyway (generally). So our best bet is to keep a stream initialization open for the duration of our file.</p>

<p>Here we do not even bother with a getter because the magic is useless information, we included the <code class="language-plaintext highlighter-rouge">assert_magic</code> function strictly so we can see whether or not the file we have open is a valid file. Letâ€™s move on in our file.</p>

<h4 id="continuation-of-top-down">Continuation of Top Down</h4>

<p>This next set of bytes is a little more tricky and require intuition. We have a byte that varies across all four files, however the remaining 3 bytes does not vary, they are constantly <code class="language-plaintext highlighter-rouge">00</code>. Bringing back some of our knowledge on binary, usually 24bit integers are not common, we see denominations of powers of 2, 4 bytes being the most common (integer). Weâ€™re going to make the assumption that this is an integer. It varies across all files. In general we make the assumption that if there is an arbitrary set of 4 bytes that does not seem to have any reference, we assume it is either going to be one of the following:</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>How we make the assumption it is this type</th>
      <th>General likelihood</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>length</td>
      <td>The given set of 4 bytes does not have all 4 bytes allocated. Eg: <code class="language-plaintext highlighter-rouge">32 00 00 00</code> or <code class="language-plaintext highlighter-rouge">19 4b 00 00</code> Usually this length refers to the next set of bytes</td>
      <td>High</td>
    </tr>
    <tr>
      <td>value</td>
      <td>The given set of 4 bytes does not have all 4 bytes allocated. Eg: <code class="language-plaintext highlighter-rouge">32 00 00 00</code> or <code class="language-plaintext highlighter-rouge">19 4b 00 00</code>. This can be very similar to a length type, so we identify a value by whether or not we are in a block, or if we know what type of data weâ€™re observing.</td>
      <td>High</td>
    </tr>
    <tr>
      <td>offset</td>
      <td>The given set of 4 bytes has a high number that exists in the file as an offset, and looks like the start of a block of information Eg: <code class="language-plaintext highlighter-rouge">32 40 b0 00</code> where the offset <code class="language-plaintext highlighter-rouge">0xb4032</code> contains a distinguishable block</td>
      <td>Medium</td>
    </tr>
    <tr>
      <td>checksum</td>
      <td>The given set of 4 bytes appears random, does not link to anywhere in the file, and appears to have no relevance, but it changes frequently between files. Eg: <code class="language-plaintext highlighter-rouge">9b 14 aa 90</code></td>
      <td>Low</td>
    </tr>
  </tbody>
</table>

<p>Based on the above we can safely assume that our value is of a length type. Letâ€™s check to validate for each save game. All 4 are <code class="language-plaintext highlighter-rouge">XX 00 00 00</code>. This number means absolutely nothing to the notes I took of the important numbers and facts in my gamesaves. So I will make the assumption this is a length and not a value. In addition to my assumption, if we read the next <code class="language-plaintext highlighter-rouge">0xXX</code> bytes of save games, our offset looks to always bee at a very large block of data. Our read data also contains (almost always) a set of <code class="language-plaintext highlighter-rouge">00 00</code> leading up to the block of garbled bytes.</p>

<h4 id="file-structures">File Structures</h4>

<p>Before we continue, you need to understand the assumptions that I am about to make for the rest of this save file. Generalizations are very good when it comes to data analytics because it helps us more quickly identify how a structure is probably going to look once we tear it apart. In general, if a save file is binarily encoded, it will follow a typical file system structure.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f8/File_table_and_inode_table.svg" alt="File Table" /></p>

<p>Almost all file tables when it comes to storing simple information will follow this design pattern. There generally will always be
1) Versioning and metadata info
2) Data Table
3) Information that links from the datatable.</p>

<p>Coincidentally this is exactly how the  Xbox 360 and windows operating systems also store their information. Microsoft loves their encapsulation. The Xbox 360 encapsulates all games in a container coined the Secure Transaction File System (STFS) which simply stores files within itself and maintains a hashtable which hashes blocks of the data from the save file for integrity. This was implemented so that designers did not have to worry about tampering, because they would have to get through the Xbox 360 file system before they even got to modify their gamesaves. To read more about how the 360 is structured you can go to <a href="http://free60.org/wiki/Main_Page">free60.org</a>.</p>

<h4 id="using-file-structuring-knowledge-to-our-advantage">Using File Structuring knowledge to our advantage</h4>

<p>In what Iâ€™m now going to call our header metadata, we have a variable number of bytes. Letâ€™s read our header data for a little bit and see if we can get the hang of this. Our next 4 bytes are static across all files <code class="language-plaintext highlighter-rouge">09 00 00 00</code>. Using our assumption table above, Iâ€™m going to test to see if this is a length. It does not appear so because there is no link to anything, also it is static. Usually a length will not be static across 5 different save games. This is probably a value then. I have no idea what type of value it could be, but my assumption would be that this is versioning information because we are still in the metadata section of the file. Usually developer include versioning information in the top of their file systems. The next 4 bytes increments by one in each of my save files <code class="language-plaintext highlighter-rouge">32 00 00 00</code>  <code class="language-plaintext highlighter-rouge">33 00 00 00</code> â€¦  This is very clearly the save number of the game.</p>

<p>We now have a set of 2 bytes that are followed by an ASCII string (my character name) . It just so happens that these two bytes when converted to a <code class="language-plaintext highlighter-rouge">uint16</code> is the exact length of my characterâ€™s name. This is a very common storage technique that C++ often uses for their string datatypes. Weâ€™re going to group this one into itâ€™s own string category.</p>

<h4 id="updated-code-with-current-extrapolated-information">Updated Code with Current Extrapolated Information</h4>

<p>Metadata reader:</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""
TESV Metadata
:author Joe Bartelmo
:filename tesv_header.py
:version 3.6
"""</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="k">class</span> <span class="nc">TESVHeaderMetadata</span><span class="p">():</span>
    <span class="s">"""
    Analyzes and reads the TESV header metadata
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="s">"""
        All we need here is the stream and rely on the parent to open and close
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">get_unknown1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Seems to be a static integer, it's probably a version, it doesn't seem
        to have any impact on the save game
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'i'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_save_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Reads back the save number in the tesv file
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'i'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_save_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="s">"""
        Sets the save number in the tesv file
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;I'</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">get_character_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Gets the current character's name
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'h'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>

    <span class="c1"># ...
</span></code></pre></div></div>

<p>Main Entry point:</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""
TESV Save game file editor example (Top Down Approach)
:author Joe Bartelmo
:filename tesv.py
:version 3.6
"""</span>
<span class="kn">from</span> <span class="nn">tesv_header</span> <span class="kn">import</span> <span class="n">TESVHeaderMetadata</span>

<span class="k">class</span> <span class="nc">TESVSaveGame</span><span class="p">():</span>
    <span class="s">"""
    Wrapper to read and write our TESV Save game
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">open_immediately</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="s">"""
        Constructor for our file editor
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">open_immediately</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">open_stream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">close_stream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Closes the initialized stream
        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">opened</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Closing Stream'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">open_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Opens the initialized stream
        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">opened</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Opening Stream'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">filepath</span><span class="p">,</span> <span class="s">'rb+'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">assert_magic</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">assert_magic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Assert that the file signature is present
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="s">"TESV_SAVEGAME"</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">13</span><span class="p">).</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">actual</span><span class="p">,</span> <span class="n">expected</span> <span class="o">+</span> <span class="s">" != "</span> <span class="o">+</span> <span class="n">actual</span>

    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        returns meta data object
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">header_size</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'i'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">TESVHeaderMetadata</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">,</span> \
                <span class="n">offset</span><span class="o">=</span><span class="n">header_size</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'-d'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'usage: python testv.py &lt;tesv_savegane&gt; [-d]'</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">&lt;tesv_savegame&gt; location of skyrim savefile'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">()</span>
    <span class="n">TESVSaveGame</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="moving-on">Moving on</h4>

<p>By now Iâ€™m sure you get the point, this is a long an tedious process. The point of this article is to show you the proper software oriented approach, and not to do this entire save file. A team of us have already accomplished this for this exact save file. If youâ€™d like you can practice and implement all of this information yourself with the data that has been previously established <a href="http://en.uesp.net/wiki/Tes5Mod:Save_File_Format">here</a>. We are now going to briefly touch on different approaches to accomplish the same end goal. This usually is not the <em>proper</em> approach as we do not obtain the maximum information or properly discover the how the file system works inside the analyzed save game.</p>

<h3 id="alternative-approaches">Alternative Approaches</h3>

<p>In general, the above approach is how we map out an entire file without reverse engineering completely how the underlying game saves. This is sadly the fastest way to fully map out an entire save game. In general there are 2 more generalized approaches that I will mention: searching and decompiling.</p>

<h4 id="decompilation-approach">Decompilation Approach</h4>

<p>This is a little old school. When you think about it, all games are just a programs that sit on the hard drive. If we can go through and isolate the moment in time that the program saves in memory, we can analyze it and figure out which numbers align with what segment of the code. The problem with this approach is that it is messy and it would take longer than it would to simply produce a bunch of game saves, record data on a notepad and pencil, and do a little digging. If you however would like to learn more about this approach, I recommend taking a look at <a href="http://boomerang.sourceforge.net/">Boomerang</a> for decompiling the executable to get the byte code locations. This may not be as fruitful however as an in-memory viewer where we can query information on the fly. My favourite application for this purpose is <a href="http://www.cheatengine.org/">CheatEngine</a> and for Linux <a href="https://github.com/scanmem/scanmem">scanmem</a>. These will let you do queries in memory for your executable and even let you manipulate the current game in action (though for newer games youâ€™ll probably just kill the executable).</p>

<p>I recommend using this approach on flash games, indie games, and any smaller game (in terms of executable size) that does not have memory scanners (See below)</p>

<h5 id="important-disclaimer">Important Disclaimer:</h5>

<p>Modifying the memory on the fly is often considered a type of malware attack, some antivirus programs will freak out when you attempt to use cheat engine or any other memory modification program. Additionally, a good deal of games have built in failsafes that detect when the memory is being modified, and have a reporting system to ban you. This is especially true for <a href="https://store.steampowered.com/">Steam</a> who has a very well known <a href="https://support.steampowered.com/kb_article.php?ref=7849-Radz-6869">VAC</a> system to secure their games. This is another reason I tend to avoid this approach.</p>

<h4 id="searching-approach-">Searching Approach *</h4>

<p><em>* most efficient approach in terms of time</em></p>

<p>This approach follows the same environment setup as the top down approach. We first obtain several gamesaves and record information about our save files just like our topdown approach and our decompilation approach. Now that we have our information we can search through the file and to find the offset of the target value to manipulate. Say for example in the given Skyrim file I wanted to modify my gold, and letâ€™s say that I currently had <code class="language-plaintext highlighter-rouge">3302</code> gold. We have multiple ways that this gold could be represented in memory, so weâ€™re going to use our Software Engineering reasoning to deduce that the value is going to be an unsigned integer (we canâ€™t have negative gold, and the default max size for most values is 32 bits).</p>

<table>
  <thead>
    <tr>
      <th>Endian</th>
      <th>Type</th>
      <th>File 1</th>
      <th>File 2</th>
      <th>File 3</th>
      <th>File 4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Little</td>
      <td>uint32</td>
      <td>N/A</td>
      <td>N/A</td>
      <td>N/A</td>
      <td>N/A</td>
    </tr>
    <tr>
      <td>Big</td>
      <td>uint32</td>
      <td>0x25663a</td>
      <td>0x25a342</td>
      <td>0x2562bc, 0x422a4d</td>
      <td>0x25976b</td>
    </tr>
  </tbody>
</table>

<p><em>Above table is an offset chart linking where the gold was found in the file</em></p>

<p>The above is an example of a dynamic value, we couldnâ€™t find a fixed position for the gold. But at least we found it! Letâ€™s take a moment and perform the following steps:</p>

<p>1) Attempt changing the value and running the game
2) Record whether or not this process worked, if it did youâ€™re good to go for the <strong>Coding Search Approach</strong> section
3) If not we need to figure out if this was a compressed block we just modified or if there is a checksum. Go to the <strong>Checksum Hunting</strong> section</p>

<h5 id="coding-search-approach">Coding Search Approach</h5>

<p>The naive approach would be to simply search for the value and modify it. The problem with this approach is that there could be duplicates (as seen by the above table under File 3). So there are two possible legitimate approaches. We can either isolate a static reference and compute the offset from the static offset, or we can fall back to the top-down approach. Although the top-down approach is the formal approach, if we are using the search approach we are in the interest of time, so letâ€™s look for a static value around our gold (note that this approach will not formally work on the Skyrim because this found value isnâ€™t actually the real gold value, itâ€™s just an artifact that reflects the gold I have). The static artifact that is a commonality among all of the files is that this value is prefixed with <code class="language-plaintext highlighter-rouge">00 00 00 00 00 00 33 00 00 00 00 33 00 00 00</code> So weâ€™re going to use this to find our target gold value. You can probably see already that this approach is fragile and will not always work.</p>

<h5 id="search-code">Search Code</h5>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""
TESV Save game file editor searching approach
:author Joe Bartelmo
:filename tesv_naive_search.py
:version 3.6
"""</span>
<span class="kn">from</span> <span class="nn">tesv_header</span> <span class="kn">import</span> <span class="n">TESVHeaderMetadata</span>

<span class="k">class</span> <span class="nc">TESVSaveGame</span><span class="p">():</span>
    <span class="s">"""
    Wrapper to read and write our TESV Save game
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">open_immediately</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="s">"""
        Constructor for our file editor
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">gold_offset</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">open_immediately</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">open_stream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">close_stream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Closes the initialized stream
        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">opened</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Closing Stream'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">open_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Opens the initialized stream
        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">opened</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Opening Stream'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">opened</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">filepath</span><span class="p">,</span> <span class="s">'rb+'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">assert_magic</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">find_gold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Determins the offset of the gold
        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">gold_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">b'</span><span class="se">\x00\x00\x00\x00\x00\x00\x33\x00\x00\x00</span><span class="s">'</span> <span class="o">+</span> \
                    <span class="s">'</span><span class="se">\x00\x33\x00\x00\x00</span><span class="s">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'Could not find static initializer for gold'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">gold_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">15</span>

    <span class="k">def</span> <span class="nf">get_gold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Returns how much gold you have
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">find_gold</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">gold_offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'i'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_gold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="s">"""
        Assigns gold to a new value
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">find_gold</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">gold_offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stream</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;I'</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'-d'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'usage: python tesv_naive_search.py &lt;tesv_savegane&gt; [-d]'</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">&lt;tesv_savegame&gt; location of skyrim savefile'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">()</span>
    <span class="n">savegame</span> <span class="o">=</span> <span class="n">TESVSaveGame</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">savegame</span><span class="p">.</span><span class="n">get_gold</span><span class="p">())</span>

</code></pre></div></div>

<h5 id="checksum-hunting">Checksum Hunting</h5>

<p>If we think there is a checksum, this raises a few concerns. We have to figure out</p>

<p>1) What data is being hashed to produce the checksum
2) What type of checksum are we looking at</p>

<h5 id="deciding-what-algorithm-they-used">Deciding what Algorithm they used</h5>

<p>Literally just bytesize, and then itâ€™s a guess or check game. You can either write a small program to compute the hash over a block of data (for all hash types) and compare, or just use HxDâ€™s built in checksum computer. Wikipedia has an excellent set of hashtypes and their digest sizes you can use to help you along <a href="https://en.wikipedia.org/wiki/List_of_hash_functions">here</a>.</p>

<h5 id="deciding-what-data-to-hash">Deciding what data to hash</h5>

<p>We need to understand that there are 2 types of developers, those that go through and try to secure their data (minority) and those that include a checksum because their boss told them. We assume the latter. Once we identify what may or may not be a checksum, we attempt to compute the checksum on all data, not including the checksum. For the latter approach, you brute force according to blocks that youâ€™ve found to narrow your approach (eg header was 54 bytes, checksum comes after, i would try computing the header).</p>

:ET