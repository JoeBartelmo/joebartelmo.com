I"Ql<p>Some things simply do not come naturally when we attempt to process data in OpenCV. In this article we’re going to focus on using <code class="language-plaintext highlighter-rouge">at&lt;T&gt;</code> in three dimensions and how I went about figuring out how to use it.</p>

<h3 id="background">Background</h3>
<p>Ideally in image processing we want to access pixel by pixel information as fast as possible. OpenCV has for loops configured in the backend such that they are roughly 10x faster when iterating by rows first, then columns (tested on 1 HPC cluster and 1 standard laptop). Typically we are all taught to use indexing to access elements as it is the most safe way (eg: <code class="language-plaintext highlighter-rouge">Mat::at&lt;T&gt;(row, col)</code>). This works find for a matrix that has a single channel, however when we want to access a matrix with multiple channels we need to use our quick math skills.</p>

<p><em>Matrix used for reader reference:</em></p>

<table>
  <thead>
    <tr>
      <th>Bands</th>
      <th>Rows</th>
      <th>Columns</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>256</td>
    </tr>
  </tbody>
</table>

<p><strong>Note:</strong> that for this article, we are under the assumption that the <code class="language-plaintext highlighter-rouge">cv::Vec3b</code> is unacceptable when programming a solution because you are attempting to work around dynamic channels/bands.</p>

<h3 id="naive-solutions">Naive Solutions</h3>
<p><em>Naive solution to indexing into a multi-dimensional matrix</em></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="c1">//process somehow</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">band</span><span class="p">;</span>
			 <span class="n">col</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span> <span class="o">*</span> <span class="n">img</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span>
			 <span class="n">col</span> <span class="o">+=</span> <span class="n">img</span><span class="p">.</span><span class="n">channels</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//process pixel:</span>
			<span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Or, alternatively split the matrix and access:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="c1">//process somehow</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">bands</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">split</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">bands</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">band</span> <span class="o">:</span> <span class="n">bands</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//process pixel:</span>
			<span class="n">band</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="incorrect-attempts-and-finding-a-solution">Incorrect Attempts and Finding a Solution</h3>
<p>I think for most cases the above will perform fine, and you will not have an immense decrease in performance (though this remains untested). However I did some digging and found the little known <code class="language-plaintext highlighter-rouge">at&lt;T&gt;(i, j, k)</code> which supposedly processes the image as though there are 3 dimensions present. According to CV Docs:</p>

<blockquote>
  <p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>

  <p>Parameters</p>

  <p>i0: Index along the dimension 0</p>

  <p>i1: Index along the dimension 1</p>

  <p>i2: Index along the dimension 2</p>
</blockquote>

<p>Although there are no instances in the documentation of its use, so i figure we are meant to use it with the band as the third dimensional, like so:</p>

<p><em>Incorrect Accessing</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="c1">//process somehow</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//process pixel:</span>
			<span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">band</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above will through a segmentation fault if there is more than 1 band present. So the ordering here is incorrect, our assumption because of the matrix I am using (see above) is that the last index is the row, because we have only 1 row in this matrix.</p>

<p>My life is wonderful. Let’s try reordering: <code class="language-plaintext highlighter-rouge">img.at&lt;double&gt;(band, col, row);</code> This will compile and run successfully, but gives us complete garbage beyond the first band. We ended up with abstractly large double floating points, It turns out that we have the following layout for our dimensions:</p>

<p><em>Matrix Information</em></p>

<table>
  <thead>
    <tr>
      <th>Bands</th>
      <th>Rows</th>
      <th>Columns</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>256</td>
    </tr>
  </tbody>
</table>

<p><em>at(i0, i1) accessor output</em></p>

<table>
  <thead>
    <tr>
      <th>i0</th>
      <th>i1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>256 * 3</td>
    </tr>
  </tbody>
</table>

<p><em>at(i0, i1, i2) accessor output</em></p>

<table>
  <thead>
    <tr>
      <th>i0</th>
      <th>i1</th>
      <th>i2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>18</td>
      <td>4422</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Huh, well that’s kinda horribly awkward. Did some more playing around with this and I found that <code class="language-plaintext highlighter-rouge">i1</code> is dependent on <code class="language-plaintext highlighter-rouge">i0</code>. The higher <code class="language-plaintext highlighter-rouge">i0</code> is the fewer numbers we have available in <code class="language-plaintext highlighter-rouge">i1</code>, <code class="language-plaintext highlighter-rouge">i2</code> is unaffected. They are linearly related by a subtraction of 256 in size except for the last index for <code class="language-plaintext highlighter-rouge">i0</code> (in this case 17). Which means that the extra X bands i found and the extra X columns i found are also garbage.</p>

<p>Freaking Fantastic. So all we know so far is that our 0th band is correct, we have to find out how to get bands 1 and 2.</p>
<h3 id="digging-intensifies-and-saddens">Digging Intensifies and Saddens</h3>
<p>After staring at this data for an increasingly depressing amount of time, I determined that only the first dimension is stored in this data buffer we are observing. Meaning that our channels are not contiguous. It appears that the rest of this data is garbage. I was unable to do any bit twiddling or engineering to determine the original data from the source. So, let’s look into how we can get the proper references to the real data.</p>

<p>Defeated, I decided to look at their source code <a href="https://github.com/opencv/opencv/blob/379ea15d1664a37a2f8851ce00e5feb8ce5b8d8d/modules/core/include/opencv2/core/mat.inl.hpp#L1175-L1180">here</a></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span> <span class="kr">inline</span>
<span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">Mat</span><span class="o">::</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span><span class="n">dims</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">CV_DbgAssert</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">i0</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">size</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span><span class="n">elemSize</span><span class="p">()</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_Tp</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">isContinuous</span><span class="p">()</span> <span class="o">||</span> <span class="n">size</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">return</span> <span class="p">((</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)[</span><span class="n">i0</span><span class="p">];</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">size</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
        <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span> <span class="o">+</span> <span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">/</span> <span class="n">cols</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">cols</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span> <span class="o">+</span> <span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">))[</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span> <span class="kr">inline</span>
<span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">Mat</span><span class="o">::</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span><span class="n">dims</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">CV_DbgAssert</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">i0</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">size</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">CV_DbgAssert</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">i1</span> <span class="o">*</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">channels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">size</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">channels</span><span class="p">()));</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span><span class="n">CV_ELEM_SIZE1</span><span class="p">(</span><span class="n">traits</span><span class="o">::</span><span class="n">Depth</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">elemSize1</span><span class="p">());</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">_Tp</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span> <span class="o">+</span> <span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i0</span><span class="p">))[</span><span class="n">i1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span> <span class="kr">inline</span>
<span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">Mat</span><span class="o">::</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CV_DbgAssert</span><span class="p">(</span> <span class="n">elemSize</span><span class="p">()</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_Tp</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">_Tp</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s take a look at the immense implementation differences between <code class="language-plaintext highlighter-rouge">at(i0)</code>, <code class="language-plaintext highlighter-rouge">at(i0,i1)</code> and <code class="language-plaintext highlighter-rouge">at(i0,i1,i2)</code>. Look past the obscure OpenCV debug assertions and take a look at the math to compute the point we are referencing. We’re simply accessing at the ptr which looks to be a reference to <a href="https://github.com/opencv/opencv/blob/66f3c1ae79030ab3cd36add4246a97f92920af84/modules/core/include/opencv2/core/mat.hpp#L2811-L2812">this</a> line of code linking to <a href="https://github.com/opencv/opencv/blob/379ea15d1664a37a2f8851ce00e5feb8ce5b8d8d/modules/core/include/opencv2/core/mat.inl.hpp#L1002-L1010">this</a> block of code</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">_Tp</span><span class="o">*</span><span class="p">)(</span><span class="n">data</span> <span class="o">+</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i1</span> <span class="o">*</span> <span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i2</span> <span class="o">*</span> <span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div></div>
<p>Fantastic. <del>Please end me</del>. Now let’s  <del>Guess and check to find the answer</del> figure out this scary math that requires knowledge of OpenCV’s internals.</p>

<p>We can derive that the math is identical for <code class="language-plaintext highlighter-rouge">at(i0, i1)</code> take a look at the similarity:
2d: <code class="language-plaintext highlighter-rouge">((_Tp*)(data + step.p[0] * i0))[i1]</code>
3d: <code class="language-plaintext highlighter-rouge">(_Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2])</code></p>

<p>So it’s completely dependent on the step size, <strong>our original incorrect ordering (row, col, band) is actually correct</strong> but we have an incorrect answer here. Let’s take a look at the step sizes:</p>

<table>
  <thead>
    <tr>
      <th>p[0]</th>
      <th>p[1]</th>
      <th>p[2]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>6144</td>
      <td>24</td>
      <td>9223372036854775808</td>
    </tr>
  </tbody>
</table>

<p>Well, from our Naive approach, that p[2] is wildly incorrect. Almost looks like unallocated space that someone left to play with me.</p>

<p>I added the line <code class="language-plaintext highlighter-rouge">step.p[2] = sizeof(double);</code> and wouldn’t you know it, worked fine. Does this mean that OpenCV is not assigning the step size properly?</p>

<h3 id="result">Result</h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lut</span><span class="p">.</span><span class="n">step</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>  
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">band</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">band</span> <span class="o">&lt;</span> <span class="n">lut</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span> <span class="n">band</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">lut</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">lut</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
            <span class="n">lut</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">band</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">}</span>
<span class="o">**</span><span class="n">Note</span><span class="o">:</span> <span class="n">See</span> <span class="n">OpenCV</span> <span class="n">Team</span> <span class="n">Response</span> <span class="n">Section</span><span class="p">,</span> <span class="n">the</span> <span class="n">above</span> <span class="n">result</span> <span class="n">is</span> <span class="n">invalid</span><span class="p">,</span> <span class="n">please</span> <span class="n">use</span> <span class="n">naive</span> <span class="n">solution</span><span class="o">**</span>
</code></pre></div></div>
<p><strong>Note:</strong> It’s possible that the above solution is improper, if you’re paranoid use one of the naive solutions, i will follow up with the OpenCV team to see if this is a possible bug.</p>

<h3 id="lessons-learned">Lesson’s Learned</h3>

<ul>
  <li>Never trust open source documentation</li>
  <li>If you can look at the source code first</li>
  <li>Try not to hate yourself</li>
</ul>

<h3 id="opencv-team-response">OpenCV Team Response</h3>

<p>Edit: 03/21/2018
I filed an open issue with the OpenCV Team and they got back to me fairly quickly (which is a super exciting thing if you know anything about the open source community). The solution provided is invalid. Apparently the 3d accessor is specifically an artifact from Mat3D and is not intended to be used in Mat (as it is considered an array). Well, I’m still glad I went through all this pain, I got to learn how CV stores it’s matricies under the hood. But if this were me I think i would remove this accessor to avoid a headache for someone else (or at least document it).</p>
:ET